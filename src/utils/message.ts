import {Serializable, SerializedConstructor} from "langchain/load/serializable";
import {MessageType, StoredMessage, StoredMessageData} from "langchain/schema";

export type MessageContent =
    | string
    | (
    | {
    type: "text";
    text: string;
}
    | {
    type: "image_url";
    image_url: string | { url: string; detail?: "auto" | "low" | "high" };
}
    )[];

export interface FunctionCall {
    /**
     * The arguments to call the function with, as generated by the model in JSON
     * format. Note that the model does not always generate valid JSON, and may
     * hallucinate parameters not defined by your function schema. Validate the
     * arguments in your code before calling your function.
     */
    arguments: string;

    /**
     * The name of the function to call.
     */
    name: string;
}

export interface ToolCall {
    /**
     * The ID of the tool call.
     */
    id: string;

    /**
     * The function that the model called.
     */
    function: FunctionCall;

    /**
     * The type of the tool. Currently, only `function` is supported.
     */
    type: "function";
}


export interface BaseMessageFields {
    content: MessageContent;
    name?: string;
    additional_kwargs?: {
        function_call?: FunctionCall;
        tool_calls?: ToolCall[];
        [key: string]: unknown;
    };
}

export abstract class BaseMessage
    extends Serializable
    implements BaseMessageFields {
    lc_namespace = ["langchain_core", "messages"];

    lc_serializable = true;

    /**
     * @deprecated
     * Use {@link BaseMessage.content} instead.
     */
    get text(): string {
        return typeof this.content === "string" ? this.content : "";
    }

    /** The content of the message. */
    content: MessageContent;

    /** The name of the message sender in a multi-user chat. */
    name?: string;

    /** Additional keyword arguments */
    additional_kwargs: NonNullable<BaseMessageFields["additional_kwargs"]>;

    /** The type of the message. */
    abstract _getType(): MessageType;

    constructor(
        fields: string | BaseMessageFields,
        /** @deprecated */
        kwargs?: Record<string, unknown>
    ) {
        if (typeof fields === "string") {
            // eslint-disable-next-line no-param-reassign
            fields = {content: fields, additional_kwargs: kwargs};
        }
        // Make sure the default value for additional_kwargs is passed into super() for serialization
        if (!fields.additional_kwargs) {
            // eslint-disable-next-line no-param-reassign
            fields.additional_kwargs = {};
        }
        super(fields);
        this.name = fields.name;
        this.content = fields.content;
        this.additional_kwargs = fields.additional_kwargs;
    }

    toDict(): StoredMessage {
        return {
            type: this._getType(),
            data: (this.toJSON() as SerializedConstructor)
                .kwargs as StoredMessageData,
        };
    }
}


export class AIMessage extends BaseMessage {
    static lc_name() {
        return "AIMessage";
    }

    _getType(): MessageType {
        return "ai";
    }
}

export class HumanMessage extends BaseMessage {
    static lc_name() {
        return "HumanMessage";
    }

    _getType(): MessageType {
        return "human";
    }
}
